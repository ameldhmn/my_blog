{
  "hash": "e2bd561c661652d026c24a225eedd6a2",
  "result": {
    "markdown": "---\ntitle: \"Exercices - Semaine 4Ô∏è‚É£\"\ndate: \"2024-03-07\"\ncategories: [code, analysis]\nimage: \"images/Image 8.jpeg\"\n---\n\n\n## Exercices - Semaine 4\n\n### Question 1\n\n#### Installez les packages devtools, httr2, jsonlite.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(devtools)\nlibrary(httr2)\nlibrary(jsonlite)\nlibrary(usethis)\nlibrary(htmltools)\nlibrary(tibble)\nlibrary(purrr)\nlibrary(leaflet)\nlibrary(sf)\nlibrary(testthat)\nlibrary(tidygeocoder)\nlibrary(roxygen2)\nlibrary(lubridate)\nlibrary(dplyr)\nlibrary(ggplot2)\n```\n:::\n\n\n### Question 2\n\n::: {style=\"text-align: justify;\"}\n#### Dans une nouvelle session R, cr√©er un nouveau projet de package intitul√© olympicsWeather en utilisant la fonction create_package de la librairie usethis. Pourquoi n‚Äôest-il pas n√©cessaire d‚Äôinstaller explicitement usethis ?\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::create_package(\"olympicsWeather\")\n```\n:::\n\n\n### Question 3\n\n::: {style=\"text-align: justify;\"}\n#### Cr√©er un nouveau script R intitul√© get_weather_forecast en utilisant la fonction usethis::use_r().\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_r(\"get_weather_forecast\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n‚úî Setting active project to '/Users/ameldahmani/Library/Mobile Documents/com~apple~CloudDocs/M1 ECAP/R avanceÃÅ/my_blog'\n‚Ä¢ Edit 'R/get_weather_forecast.R'\n```\n:::\n:::\n\n\n### Question 4\n\n::: {style=\"text-align: justify;\"}\n#### Sans impl√©menter la fonction pour l‚Äôinstant, √©crivez une requ√™te d‚Äôapi en utilisant la librairie httr2 que vous aurez pr√©alablement install√©.\n\n‚Ä¢ l‚Äôurl de l‚Äôapi open-api est la suivante:¬†[https://api.open-meteo.com/v1/forecast](https://www.google.com/url?q=https://api.open-meteo.com/v1/forecast&source=gmail-html&ust=1708971790254000&usg=AOvVaw1RR4vboZVa1vX4Vubr9VIU)\\\n‚Ä¢ vous utiliserez les fonctions request, req_url_query, req_perform, resp_body_json pour passer la requ√™te. Ces instructions peuvent se cha√Æner avec des pipes. La fonction request permet d‚Äôinitialiser l‚Äôobjet de request en passant l‚Äôurl de l‚Äôapi. La fonction req_url_query permet de passer diff√©rents param√®tres √† la requ√™te, quand req_perform ex√©cute la requ√™te et r√©cup√®re les r√©sultats dans la session R. Enfin, la fonction resp_body_json extrait les donn√©es retourn√©es en json du r√©sultat de la requ√™te. Vous pourrez utiliser la fonction tibble::as_tibble() pour convertir en tibble la table retourn√©e.\\\n‚Ä¢ pour la premi√®re requ√™te, nous souhaitons obtenir la pr√©vision m√©t√©o aux coordonn√©es g√©ographiques c(48.85, 2.35)\\\n‚Ä¢nous souhaitons obtenir les informations de temp√©ratures, de temp√©ratures ressenties, de probabilit√© de pr√©cipitation, et de quantit√©s de pr√©cipitations. Indice, vous devrez passer le param√®tre suivant (entre autres) hourly= c(‚Äútemperature_2m‚Äù, ‚Äúapparent_temperature‚Äù, ‚Äúprecipitation_probability‚Äù, ‚Äúprecipitation‚Äù) √† la fonction req_url_query\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurl <- \"https://api.open-meteo.com/v1/forecast\"\nrequest(url) |>\n  req_url_query(latitude = 48.85,\n                longitude = 2.35,\n                hourly= c(\"temperature_2m\",\n                          \"apparent_temperature\",\n                          \"precipitation_probability\",\n                          \"precipitation\"),\n                .multi = \"comma\") |>\n  req_perform() |>\n  resp_body_json() |>\n  tibble::as_tibble()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 √ó 9\n  latitude longitude generationtime_ms utc_offset_seconds timezone\n     <dbl>     <dbl>             <dbl>              <int> <chr>   \n1     48.8      2.36             0.121                  0 GMT     \n2     48.8      2.36             0.121                  0 GMT     \n3     48.8      2.36             0.121                  0 GMT     \n4     48.8      2.36             0.121                  0 GMT     \n5     48.8      2.36             0.121                  0 GMT     \n# ‚Ñπ 4 more variables: timezone_abbreviation <chr>, elevation <dbl>,\n#   hourly_units <named list>, hourly <named list>\n```\n:::\n:::\n\n\n### Question 5\n\n::: {style=\"text-align: justify;\"}\n#### D√©crivez le r√©sultat. Qu‚Äôavons nous obtenu suite √† notre requ√™te ? Quels param√®tres souhaitons nous changer si nous voulons pouvoir r√©cup√©rer les pr√©visions m√©t√©o pour tous les sites des JOs ?\n:::\n\n::: {style=\"text-align: justify;\"}\nNous avons obtenu un tibble qui contient plusieurs informations m√©t√©orologiques pour un endroit sp√©cifique situ√© √† la latitude 48.85 et la longitude 2.85.\n\nCe tibble comporte cinq lignes, chacune repr√©sentant un aspect diff√©rent des donn√©es m√©t√©orologiques.\n\nIl est par ailleurs compos√© de neuf colonnes, incluant notamment les latitudes et longitudes, les unit√©s des mesures horaires de chaque ligne, l'abr√©viation du fuseau horaire, le fuseau goraire, l'√©l√©vation de l'endroit, et une colonne appel√©e ‚Äúhourly‚Äù, qui pr√©sente les horaires et qui est particuli√®rement int√©ressante. Dans cette colonne ‚Äúhourly‚Äù, chaque param√®tre m√©t√©orologique est repr√©sent√© par une liste, refl√©tant son √©volution dans le temps √† une adresse sp√©cifique. Ainsi, pour chaque site, nous pouvons observer comment les diff√©rents param√®tres m√©t√©orologiques √©voluent heure par heure.\n\nCependant, pour collecter les pr√©visions m√©t√©orologiques pour tous les sites des Jeux Olympiques, il est n√©cessaire d'ajuster la longitude et la latitude correspondant √† chaque site. Par cons√©quent, nous devons cr√©er une fonction qui recueille initialement la latitude et la longitude pour chaque site olympique. Cette fonction nous permettra d'interroger l'API m√©t√©o avec les coordonn√©es correctes pour obtenir les donn√©es m√©t√©orologiques sp√©cifiques √† chaque site. En ajustant les coordonn√©es, nous pourrons ainsi obtenir les pr√©visions m√©t√©orologiques pour tous les sites des Jeux Olympiques.\n:::\n\n### Question 6\n\n::: {style=\"text-align: justify;\"}\n#### L‚Äôobjectif est donc d‚Äôimpl√©menter une fonction get_weather_forecast pour r√©cup√©rer une table de pr√©visions m√©t√©o √† une coordonn√©es GPS donn√©e. Avant d‚Äôimpl√©menter cette fonction accessible √† l‚Äôutilisateur, nous souhaitons impl√©menter plusieurs fonctions internes\n:::\n\n### Question 7\n\n#### Fonction perform_request:\n\n::: {style=\"text-align: justify;\"}\n‚Ä¢ la fonction perform request prend en entr√©e deux arguments: latitude et longitude\\\n‚Ä¢ elle effectue la requ√™te sur l‚Äôapi publique ci-dessus, et retourne le contenu du body sous forme d‚Äôune tibble (exactement comme dans la question 4)\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' @param latitude latitude (numeric)\n#' @param longitude longitude (numeric)\n#' @return le contenu du body sous forme d'un tibble de 5 lignes et 9 colonnes\nperform_request <- function(latitude, longitude){\n  url <- \"https://api.open-meteo.com/v1/forecast\"\n  request(url) |>\n    req_url_query(latitude = latitude,\n                  longitude = longitude,\n                  hourly= c(\"temperature_2m\",\n                            \"apparent_temperature\",\n                            \"precipitation_probability\",\n                            \"precipitation\"),\n                  .multi = \"comma\") |>\n    req_perform() |>\n    resp_body_json() |>\n    as_tibble()\n}\nresp <- perform_request(47.216671, -1.55)\nresp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 √ó 9\n  latitude longitude generationtime_ms utc_offset_seconds timezone\n     <dbl>     <dbl>             <dbl>              <int> <chr>   \n1     47.2     -1.55             0.261                  0 GMT     \n2     47.2     -1.55             0.261                  0 GMT     \n3     47.2     -1.55             0.261                  0 GMT     \n4     47.2     -1.55             0.261                  0 GMT     \n5     47.2     -1.55             0.261                  0 GMT     \n# ‚Ñπ 4 more variables: timezone_abbreviation <chr>, elevation <dbl>,\n#   hourly_units <named list>, hourly <named list>\n```\n:::\n:::\n\n\nNotre fonction op√®re de mani√®re efficace, permettant la r√©cup√©ration des donn√©es m√©t√©orologiques de tout point en utilisant simplement ses coordonn√©es GPS, √† savoir, la latitude et la longitude.\n\n### Question 8\n\n#### Fonction unnest_response:\n\n‚Ä¢ les r√©sultats obtenus apr√®s la requ√™te n‚Äô√©tant pas bien formatt√©s, il faut √©crire une fonction pour transformer la forme de la tibble obtenue\\\n‚Ä¢ la fonction en entr√©e prendre une tibble au format issu de la requ√™te\\\n‚Ä¢ et retournera les m√™mes donn√©es au schema suivant:\\\n‚Äì date_heure: heure au tz UTC\\\n‚Äì tempature_celsius: donn√©es de temp√©rature\\\n‚Äì temperature_ressentie_celsius: donn√©es de temp√©rature ressentie\\\n‚Äì precipation_proba: probabilit√© de pluie\\\n‚Äì precipitation: precipitation en mm\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' D√©compacte les donn√©es de r√©ponse des pr√©visions m√©t√©orologiques.\n#'\n#' @param resp R√©sultat de la fonction pr√©c√©dente, tibble 5x9\n#' @return Un nouveau tibble comprenant 168 observations et 5 variables\n#' @export\nunnest_response <- function(resp){\n  hourly_donnees <- resp$hourly\n  if (length(hourly_donnees) == 0) {\n    stop(\"Aucune donn√©e dans la colonne 'hourly'.\")\n  }\n  output_tibble <- tibble(\n    \"heure au tz UTC\" = with_tz(unlist(hourly_donnees[[1]]), tzone = \"UTC\"),\n    \"donn√©es de temp√©rature\" = unlist(hourly_donnees[[2]]),\n    \"donn√©es de temp√©rature ressentie\" = unlist(hourly_donnees[[3]]),\n    \"probabilit√© de pluie\" = unlist(hourly_donnees[[4]]),\n    \"precipitation en mm\" = unlist(hourly_donnees[[5]])\n  )\n  return(output_tibble)\n}\nresp2 <- unnest_response(resp)\nresp2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 168 √ó 5\n   `heure au tz UTC`   `donn√©es de temp√©rature` donn√©es de temp√©rature ressent‚Ä¶¬π\n   <dttm>                                 <dbl>                            <dbl>\n 1 2024-03-07 23:00:00                      8.8                              4.8\n 2 2024-03-07 23:00:00                      8.4                              4.6\n 3 2024-03-07 23:00:00                      7.6                              4.1\n 4 2024-03-07 23:00:00                      7.6                              4.1\n 5 2024-03-07 23:00:00                      7.7                              4.5\n 6 2024-03-07 23:00:00                      7.7                              4.3\n 7 2024-03-07 23:00:00                      7                                3.8\n 8 2024-03-07 23:00:00                      7                                3.9\n 9 2024-03-07 23:00:00                      7.2                              3.8\n10 2024-03-07 23:00:00                      9.1                              6.4\n# ‚Ñπ 158 more rows\n# ‚Ñπ abbreviated name: ¬π‚Äã`donn√©es de temp√©rature ressentie`\n# ‚Ñπ 2 more variables: `probabilit√© de pluie` <int>, `precipitation en mm` <dbl>\n```\n:::\n:::\n\n\n### Question 9\n\n#### Tests unitaires pour la fonction unnest_response:\n\n‚Ä¢ cr√©ez un script de tests en utilisant la fonction usethis::use_test(‚Äúunnest_response‚Äù)\\\n‚Ä¢ dans ce script, cr√©ez un jeu de donn√©es minimal pour tester le comportement de la fonction\\\n‚Ä¢ testez la fonction, en proposant plusieurs tests unitaires. Exemple de tests unitaires:\\\n‚Äì testez que la fonction renvoie le bon nombre de lignes\\\n‚Äì testez que les valeurs de la colonne temperature correspondent aux valeur propos√©es en entr√©e\\\n‚Äì testez le nom des colonnes en sortie\\\n‚Äì testez le nombre de colonnes en sortie\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_test(\"unnest_response\")\ntestthat::test_dir('tests/testthat/')\n```\n:::\n\n\n##### cr√©ation du jeu de donn√©es minimal pour tester le comportement de la fonction\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_resp <- list(\n  hourly = list(\n    heure = ymd_hms(\"2024-03-05 08:00:00\", tz = \"UTC\"),\n    temperature = c(10, 12, 14),\n    temperature_ressentie = c(8, 10, 12),\n    probabilite_pluie = c(0.1, 0.2, 0.3),\n    precipitation_mm = c(0, 0.5, 1)\n  )\n)\n```\n:::\n\n\n##### test que la fonction renvoie le bon nombre de lignes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"La fonction renvoie le bon nombre de lignes\", {\n  resp <- unnest_response(test_resp)\n  expect_equal(nrow(resp), 3)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest passed üéâ\n```\n:::\n:::\n\n\n##### test que les valeurs de la colonne temperature correspondent aux valeur propos√©es en entr√©e\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"Les valeurs de la colonne temperature correspondent aux valeurs propos√©es en entr√©e\", {\n  resp <- unnest_response(test_resp)\n  expect_equal(resp$`donn√©es de temp√©rature`, c(10, 12, 14))\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest passed üò∏\n```\n:::\n:::\n\n\n##### test le nom des colonnes en sortie\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"Le nom des colonnes en sortie est correct\", {\n  resp <- unnest_response(test_resp)\n  expect_named(resp, c(\"heure au tz UTC\", \"donn√©es de temp√©rature\", \"donn√©es de temp√©rature ressentie\", \"probabilit√© de pluie\", \"precipitation en mm\"))\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest passed üéâ\n```\n:::\n:::\n\n\n##### test le nombre de colonnes en sortie\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"Le nombre de colonnes en sortie est correct\", {\n  resp <- unnest_response(test_resp)\n  expect_equal(ncol(resp), 5)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest passed ü•≥\n```\n:::\n:::\n\n\nLa fonction ‚Äúunnest_response‚Äù r√©ussit tous les tests.\n\n### Question 10\n\n::: {style=\"text-align: justify;\"}\n#### Lors de la seÃÅance 1, nous avons deÃÅveloppeÃÅ un outil permettant de trouver les coordonneÃÅes GPS aÃÄ partir d‚Äôun nom d‚Äôadresse (en utilisant le package tidygeocoder et la fonction reverse_geocode). Nous souhaitons que l‚Äôutilisateur puisse obtenir des preÃÅvisions meÃÅteÃÅos aÃÄ partir de:\n:::\n\n‚Ä¢ coordonneÃÅes GPS, i.e un vecteur numeÃÅrique de taille 2\\\n\n‚Ä¢ un nom de site olympique ou une adresse. A partir du code de la seÃÅance 1, deÃÅfinissez une fonction address_to_gps convertissant une adresse en coordonneÃÅes gps sous la forme d‚Äôun vecteur numeÃÅrique de taille 2.\n\nDeÃÅfinir une fonction get_forecast geÃÅneÃÅrique, et deux impleÃÅmentations get_forecast.character et get_forecast.numeric.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Convertit une adresse en coordonn√©es GPS.\n#'\n#' @param adresse Adresse √† g√©ocoder\n#' @return Coordonn√©es GPS obtenues √† partir de l'adresse\naddress_to_gps <- function(adresse) {\n  df_adresse <- data.frame(\"nom\" = character(), addr = character(), stringsAsFactors = FALSE)\n\n  df_adresse <- rbind(df_adresse, data.frame(addr = adresse), stringsAsFactors = FALSE)\n\n  resultat_geocodage <- df_adresse |>\n    geocode(addr, method = 'arcgis')\n\n  df_adresse <- resultat_geocodage\n\n  return(df_adresse)\n  print(df_adresse)\n}\n\nresultat10 <- as_tibble(address_to_gps(\"B√¢timent Erdre, Chem. de la Censive du Tertre, 44300 Nantes\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPassing 1 address to the ArcGIS single address geocoder\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nQuery completed in: 0.5 seconds\n```\n:::\n\n```{.r .cell-code}\nresultat10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 √ó 3\n  addr                                                          lat  long\n  <chr>                                                       <dbl> <dbl>\n1 B√¢timent Erdre, Chem. de la Censive du Tertre, 44300 Nantes  47.2 -1.55\n```\n:::\n\n```{.r .cell-code}\nlibrary(leaflet)\ncarte <- leaflet()  |> \n  addTiles()  |> \n  addMarkers(lng = resultat10$long, lat = resultat10$lat, popup = \"IAE Nantes\")\ncarte\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"leaflet html-widget html-fill-item\" id=\"htmlwidget-f1318d4a1722299f0eed\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-f1318d4a1722299f0eed\">{\"x\":{\"options\":{\"crs\":{\"crsClass\":\"L.CRS.EPSG3857\",\"code\":null,\"proj4def\":null,\"projectedBounds\":null,\"options\":{}}},\"calls\":[{\"method\":\"addTiles\",\"args\":[\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",null,null,{\"minZoom\":0,\"maxZoom\":18,\"tileSize\":256,\"subdomains\":\"abc\",\"errorTileUrl\":\"\",\"tms\":false,\"noWrap\":false,\"zoomOffset\":0,\"zoomReverse\":false,\"opacity\":1,\"zIndex\":1,\"detectRetina\":false,\"attribution\":\"&copy; <a href=\\\"https://openstreetmap.org/copyright/\\\">OpenStreetMap<\\/a>,  <a href=\\\"https://opendatacommons.org/licenses/odbl/\\\">ODbL<\\/a>\"}]},{\"method\":\"addMarkers\",\"args\":[47.243139604933,-1.554257933235,null,null,null,{\"interactive\":true,\"draggable\":false,\"keyboard\":true,\"title\":\"\",\"alt\":\"\",\"zIndexOffset\":0,\"opacity\":1,\"riseOnHover\":false,\"riseOffset\":250},\"IAE Nantes\",null,null,null,null,{\"interactive\":false,\"permanent\":false,\"direction\":\"auto\",\"opacity\":1,\"offset\":[0,0],\"textsize\":\"10px\",\"textOnly\":false,\"className\":\"\",\"sticky\":true},null]}],\"limits\":{\"lat\":[47.243139604933,47.243139604933],\"lng\":[-1.554257933235,-1.554257933235]}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n##### Fonction g√©n√©rique pour obtenir les pr√©visions m√©t√©o\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_forecast <- function(location, ...) {\n  UseMethod(\"get_forecast\", location)\n}\n```\n:::\n\n\n##### Impl√©mentation pour les caract√®res\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_forecast.character <- function(location, ...) {\n  coords <- address_to_gps(location)\n  return(perform_request(coords[2], coords[1], ...))\n}\n```\n:::\n\n\n##### Impl√©mentation pour les vecteurs num√©riques (coordonn√©es GPS par exemple)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_forecast.numeric <- function(location, ...) {\n  return(perform_request(location[2], location[1], ...))\n}\n```\n:::\n\n\n::: {style=\"text-align: justify;\"}\nPour valider l'exactitude des coordonn√©es de l'adresse renseign√©e, il convenait d'utiliser la fonction pour r√©cup√©rer les coordonn√©es GPS associ√©es √† cette adresse. Ensuite, de visualier la cartographique qui affiche ces coordonn√©es sur une carte g√©ographique. Cette visualisation a permis de v√©rifier visuellement si les coordonn√©es r√©cup√©r√©es correspondent √† l'emplacement attendu sur la carte.\n:::\n\n### Question 11\n\n#### ImpleÃÅmentez une fonction interne get_gps_coordinate renvoyant des coordonneÃÅes x,y pour une adresse en utilisant les fonctions de la question 10 (ou de la semaine 1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Obtient les coordonn√©es GPS √† partir d'une adresse.\n#'\n#' @param adresse Adresse √† g√©ocoder\n#' @return Coordonn√©es GPS obtenues √† partir de l'adresse\n#' @export\nget_gps_coordinate <- function(adresse) {\n  resultat_geocodage <- address_to_gps(adresse)\n\n  coordonnees <- c(resultat_geocodage$lat, resultat_geocodage$long)\n\n  return(coordonnees)\n  print(coordonnees)\n}\n\nget_gps_coordinate(\"B√¢timent Erdre, Chem. de la Censive du Tertre, 44300 Nantes\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPassing 1 address to the ArcGIS single address geocoder\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nQuery completed in: 0.1 seconds\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 47.243140 -1.554258\n```\n:::\n:::\n\n\nNotre fonction renvoie avec pr√©cision les coordonn√©es du lieu demand√©.\n\n### Question 12\n\n::: {style=\"text-align: justify;\"}\n#### ImpleÃÅmentez la fonction get_forecast.numeric. Cette fonction prend en entreÃÅe un argument xy, contenant un vecteur numeÃÅrique de coordonneÃÅes x,y (latitude, longitude) de taille 2. Si cette condition n‚Äôest pas veÃÅrifieÃÅe, alors la fonction devra deÃÅclarer une erreur. La fonction appelera les deux fonctions perform_request et unnest_response avant de retourner la tibble de reÃÅsultat.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Obtient les pr√©visions m√©t√©orologiques √† partir de coordonn√©es GPS.\n#'\n#' @param xy Vecteur num√©rique avec x les latitudes et y les longitudes\n#' @return Un tibble 168x5\n#' @export\nget_forecast.numeric <- function(xy, ...) {\n  if (!is.numeric(xy) || length(xy) != 2) {\n    stop(\"Erreur ! L'argument xy doit √™tre un vecteur num√©rique de taille 2 !\")\n  }\n\n  response_table <- perform_request(xy[2], xy[1], ...)\n\n  unnested_table <- unnest_response(response_table)\n\n  return(unnested_table)\n}\n\nxy <- c(47.243140, -1.554258)\nresultat12 <- get_forecast.numeric(xy)\nresultat12\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 168 √ó 5\n   `heure au tz UTC`   `donn√©es de temp√©rature` donn√©es de temp√©rature ressent‚Ä¶¬π\n   <dttm>                                 <dbl>                            <dbl>\n 1 2024-03-07 23:00:00                     28.5                             34  \n 2 2024-03-07 23:00:00                     28.5                             34  \n 3 2024-03-07 23:00:00                     28.6                             34.1\n 4 2024-03-07 23:00:00                     28.6                             34.1\n 5 2024-03-07 23:00:00                     28.8                             34.1\n 6 2024-03-07 23:00:00                     29                               34  \n 7 2024-03-07 23:00:00                     29                               33.8\n 8 2024-03-07 23:00:00                     29.1                             34.9\n 9 2024-03-07 23:00:00                     29.2                             36  \n10 2024-03-07 23:00:00                     29.3                             36.8\n# ‚Ñπ 158 more rows\n# ‚Ñπ abbreviated name: ¬π‚Äã`donn√©es de temp√©rature ressentie`\n# ‚Ñπ 2 more variables: `probabilit√© de pluie` <int>, `precipitation en mm` <dbl>\n```\n:::\n:::\n\n\n::: {style=\"text-align: justify;\"}\nNotre fonction est efficace puisqu'elle signale correctement les erreurs lorsque le vecteur n'est ni num√©rique ni de taille 2, et r√©cup√®re avec succ√®s les donn√©es m√©t√©orologiques pour les coordonn√©es fournies lorsqu'elles sont un vecteur num√©rique de taille 2.\n:::\n\n### Question 13\n\n::: {style=\"text-align: justify;\"}\n#### ImpleÃÅmentez la fonction get_forecast.character. Cette fonction prend en entreÃÅe un argument address, de type character, de taille 1. Si cette condition n‚Äôest pas veÃÅrifieÃÅe, alors la fonction devra deÃÅclarer une erreur. La fonction appelera les deux fonctions address_to_gps puis la fonction get_forecast en passant le reÃÅsultat de l‚Äôappel aÃÄ address_to_gps.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Pr√©visions m√©t√©orologiques √† partir d'une adresse.\n#'\n#' @param adresse Adresse √† g√©ocoder\n#' @return Les pr√©visions m√©t√©orologiques obtenues\n#' @export\nforecast.character <- function(adresse) {\n  if (!is.character(adresse) || length(adresse) != 1) {\n    stop(\"L'argument address doit √™tre de type character et de taille 1.\")\n  }\n}\n\n#' Obtient les pr√©visions m√©t√©orologiques √† partir d'une adresse.\n#'\n#' @param adresse Adresse √† g√©ocoder\n#' @return Les pr√©visions m√©t√©orologiques obtenues\n#' @export\nget_forecast.character <- function(adresse) {\n  forecast.character(adresse)\n  \n  coordinates <- get_gps_coordinate(adresse)\n  \n  resultat_previsions <- perform_request(latitude = coordinates[1], longitude = coordinates[2])\n  resultat_traitement <- unnest_response(resultat_previsions)\n  \n  return(resultat_traitement)\n}\n\nget_forecast.character(\"46, rue Proudhon, 93210, Saint-Denis, France\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPassing 1 address to the ArcGIS single address geocoder\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nQuery completed in: 0.9 seconds\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 168 √ó 5\n   `heure au tz UTC`   `donn√©es de temp√©rature` donn√©es de temp√©rature ressent‚Ä¶¬π\n   <dttm>                                 <dbl>                            <dbl>\n 1 2024-03-07 23:00:00                      5.9                              2.5\n 2 2024-03-07 23:00:00                      5.1                              1.9\n 3 2024-03-07 23:00:00                      4.5                              1.3\n 4 2024-03-07 23:00:00                      4.2                              1  \n 5 2024-03-07 23:00:00                      3.7                              0.5\n 6 2024-03-07 23:00:00                      3.2                              0.2\n 7 2024-03-07 23:00:00                      3                               -0.2\n 8 2024-03-07 23:00:00                      2.9                             -0.2\n 9 2024-03-07 23:00:00                      3.8                              0.5\n10 2024-03-07 23:00:00                      6.5                              2.9\n# ‚Ñπ 158 more rows\n# ‚Ñπ abbreviated name: ¬π‚Äã`donn√©es de temp√©rature ressentie`\n# ‚Ñπ 2 more variables: `probabilit√© de pluie` <int>, `precipitation en mm` <dbl>\n```\n:::\n\n```{.r .cell-code}\nget_forecast.numeric(c(47.243140, -1.554258))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 168 √ó 5\n   `heure au tz UTC`   `donn√©es de temp√©rature` donn√©es de temp√©rature ressent‚Ä¶¬π\n   <dttm>                                 <dbl>                            <dbl>\n 1 2024-03-07 23:00:00                     28.5                             34  \n 2 2024-03-07 23:00:00                     28.5                             34  \n 3 2024-03-07 23:00:00                     28.6                             34.1\n 4 2024-03-07 23:00:00                     28.6                             34.1\n 5 2024-03-07 23:00:00                     28.8                             34.1\n 6 2024-03-07 23:00:00                     29                               34  \n 7 2024-03-07 23:00:00                     29                               33.8\n 8 2024-03-07 23:00:00                     29.1                             34.9\n 9 2024-03-07 23:00:00                     29.2                             36  \n10 2024-03-07 23:00:00                     29.3                             36.8\n# ‚Ñπ 158 more rows\n# ‚Ñπ abbreviated name: ¬π‚Äã`donn√©es de temp√©rature ressentie`\n# ‚Ñπ 2 more variables: `probabilit√© de pluie` <int>, `precipitation en mm` <dbl>\n```\n:::\n:::\n\n\nLa fonction op√®re correctement.\n\n### Question 14\n\n#### Documentez la fonction get_forecast en utilisant les balises Roxygen approprieÃÅes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' get_forecast\n#'\n#' Cette fonction g√©n√©rique permet d'obtenir des pr√©visions m√©t√©orologiques en fonction d'une localisation.\n#' Elle a deux impl√©mentations sp√©cifiques :\n#'   - get_forecast.character : pour obtenir des pr√©visions √† partir d'un nom de site olympique ou d'une adresse.\n#'   - get_forecast.numeric : pour obtenir des pr√©visions √† partir des coordonn√©es GPS.\n#'\n#' @param location Emplacement pour obtenir les pr√©visions (Adresse, nom de site olympique ou coordonn√©es GPS).\n#'   - Pour get_forecast.character : un caract√®re de taille 1.\n#'   - Pour get_forecast.numeric : un vecteur num√©rique de taille 2 (latitude, longitude).\n#' @return Un tibble contenant les pr√©visions m√©t√©orologiques.\n#' @examples\n#' Exemples d'utilisation :\n#' \\dontrun{\n#'   # Exemples d'utilisation\n#'   get_forecast(\"Nantes\")\n#'   get_forecast(c(48.85, 2.35))\n#' }\n#'\n#' @seealso\n#' \\code{\\link{get_forecast.character}}, \\code{\\link{get_forecast.numeric}},\n#' \\code{\\link{perform_request}}, \\code{\\link{unnest_response}}\n#'\n#' @export\nget_forecast <- function(x) {\n  if (is.numeric(x)) {\n    get_forecast.numeric(x)\n  } else if (is.character(x)) {\n    get_forecast.character(x)\n  } else {\n    stop(\"L'argument doit √™tre de type numeric (coordonn√©es) ou character (adresse).\")\n  }\n}\n\nresultat14 <-get_forecast(\"District de Huairou, Chine, 101406\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPassing 1 address to the ArcGIS single address geocoder\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nQuery completed in: 0.3 seconds\n```\n:::\n\n```{.r .cell-code}\nprint(resultat14)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 168 √ó 5\n   `heure au tz UTC`   `donn√©es de temp√©rature` donn√©es de temp√©rature ressent‚Ä¶¬π\n   <dttm>                                 <dbl>                            <dbl>\n 1 2024-03-07 23:00:00                      0.3                             -3.6\n 2 2024-03-07 23:00:00                      2.8                             -1.1\n 3 2024-03-07 23:00:00                      5.6                              1.6\n 4 2024-03-07 23:00:00                      7.7                              4.4\n 5 2024-03-07 23:00:00                      9.1                              6.6\n 6 2024-03-07 23:00:00                     10.1                              7.5\n 7 2024-03-07 23:00:00                      9.7                              6.8\n 8 2024-03-07 23:00:00                     10.1                              6.6\n 9 2024-03-07 23:00:00                     10                                5.8\n10 2024-03-07 23:00:00                      9.7                              5.5\n# ‚Ñπ 158 more rows\n# ‚Ñπ abbreviated name: ¬π‚Äã`donn√©es de temp√©rature ressentie`\n# ‚Ñπ 2 more variables: `probabilit√© de pluie` <int>, `precipitation en mm` <dbl>\n```\n:::\n\n```{.r .cell-code}\nresultat14bis <-get_forecast(c(47.243140, -1.554258))\nprint(resultat14bis)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 168 √ó 5\n   `heure au tz UTC`   `donn√©es de temp√©rature` donn√©es de temp√©rature ressent‚Ä¶¬π\n   <dttm>                                 <dbl>                            <dbl>\n 1 2024-03-07 23:00:00                     28.5                             34  \n 2 2024-03-07 23:00:00                     28.5                             34  \n 3 2024-03-07 23:00:00                     28.6                             34.1\n 4 2024-03-07 23:00:00                     28.6                             34.1\n 5 2024-03-07 23:00:00                     28.8                             34.1\n 6 2024-03-07 23:00:00                     29                               34  \n 7 2024-03-07 23:00:00                     29                               33.8\n 8 2024-03-07 23:00:00                     29.1                             34.9\n 9 2024-03-07 23:00:00                     29.2                             36  \n10 2024-03-07 23:00:00                     29.3                             36.8\n# ‚Ñπ 158 more rows\n# ‚Ñπ abbreviated name: ¬π‚Äã`donn√©es de temp√©rature ressentie`\n# ‚Ñπ 2 more variables: `probabilit√© de pluie` <int>, `precipitation en mm` <dbl>\n```\n:::\n:::\n\n\n### Question 15\n\n#### Mettez aÃÄ jour le fichier DESCRIPTION. Assurez-vous d‚Äôavoir un NAMESPACE aÃÄ jour en utilisant devtools::document.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(olympicsWeather)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'olympicsWeather'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked _by_ '.GlobalEnv':\n\n    forecast.character, get_forecast, get_forecast.character,\n    get_forecast.numeric, get_gps_coordinate, perform_request,\n    unnest_response\n```\n:::\n\n```{.r .cell-code}\nhelp(\"get_forecast\")\n```\n:::\n\n\n### Question bonus\n\n#### Quelle strateÃÅgie employeriez-vous pour fournir une sortie visuelle aux utilisateurs ? Essayez de proposer une fonction dans le package pour rendre visuelle la sortie du package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Visualise les emplacements des pr√©visions m√©t√©orologiques sur une carte Leaflet\n#'\n#' @param forecast_locations Un data frame contenant les emplacements des pr√©visions m√©t√©orologiques avec au moins deux colonnes : long (longitude) et lat (latitude).\n#' @return Une carte Leaflet avec des marqueurs pour les emplacements des pr√©visions m√©t√©orologiques.\n#' @export\nvisualiser_carte <- function(forecast_locations) {\n  require(leaflet)\n  \n  ma_carte <- leaflet() %>%\n    addTiles() %>%\n    addMarkers(lng = forecast_locations$long, lat = forecast_locations$lat)\n  \n  return(ma_carte)\n}\n\n\n#exemple d'utilisation \nexemple1 <- data.frame(\n  long = c(-0.1278, -73.935242, 151.2093), \n  lat = c(51.5074, 40.730610, -33.8688)  \n)\nma_carte <- visualiser_carte(exemple1)\nma_carte\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"leaflet html-widget html-fill-item\" id=\"htmlwidget-89420483261b7e719bd0\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-89420483261b7e719bd0\">{\"x\":{\"options\":{\"crs\":{\"crsClass\":\"L.CRS.EPSG3857\",\"code\":null,\"proj4def\":null,\"projectedBounds\":null,\"options\":{}}},\"calls\":[{\"method\":\"addTiles\",\"args\":[\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",null,null,{\"minZoom\":0,\"maxZoom\":18,\"tileSize\":256,\"subdomains\":\"abc\",\"errorTileUrl\":\"\",\"tms\":false,\"noWrap\":false,\"zoomOffset\":0,\"zoomReverse\":false,\"opacity\":1,\"zIndex\":1,\"detectRetina\":false,\"attribution\":\"&copy; <a href=\\\"https://openstreetmap.org/copyright/\\\">OpenStreetMap<\\/a>,  <a href=\\\"https://opendatacommons.org/licenses/odbl/\\\">ODbL<\\/a>\"}]},{\"method\":\"addMarkers\",\"args\":[[51.5074,40.73061,-33.8688],[-0.1278,-73.935242,151.2093],null,null,null,{\"interactive\":true,\"draggable\":false,\"keyboard\":true,\"title\":\"\",\"alt\":\"\",\"zIndexOffset\":0,\"opacity\":1,\"riseOnHover\":false,\"riseOffset\":250},null,null,null,null,null,{\"interactive\":false,\"permanent\":false,\"direction\":\"auto\",\"opacity\":1,\"offset\":[0,0],\"textsize\":\"10px\",\"textOnly\":false,\"className\":\"\",\"sticky\":true},null]}],\"limits\":{\"lat\":[-33.8688,51.5074],\"lng\":[-73.935242,151.2093]}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Visualise les pr√©visions m√©t√©orologiques\n#'\n#' @param forecast_data Un data frame contenant les donn√©es de pr√©visions m√©t√©orologiques avec au moins deux colonnes : date et temp√©rature.\n#' @return Un objet ggplot repr√©sentant les pr√©visions m√©t√©orologiques.\n#' @export\nvisualiser_previsions <- function(forecast_data) {\n  require(ggplot2)\n  \n  ggplot(data = forecast_data, aes(x = date, y = temperature)) +\n    geom_line() +\n    labs(title = \"Pr√©vision de la temp√©rature\", x = \"Date\", y = \"Temp√©rature (¬∞C)\")\n}\n\n#exemple d'utilisation \nexemple2 <- data.frame(\n  date = seq(as.Date(\"2022-01-01\"), by = \"day\", length.out = 7), \n  temperature = c(20, 22, 23, 25, 24, 23, 22) \n)\n\nmon_graph <- visualiser_previsions(exemple2)\nprint(mon_graph)\n```\n\n::: {.cell-output-display}\n![](Exercice4_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Exercice4_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../site_libs/leaflet-1.3.1/leaflet.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/leaflet-1.3.1/leaflet.js\"></script>\n<link href=\"../../site_libs/leafletfix-1.0.0/leafletfix.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/proj4-2.6.2/proj4.min.js\"></script>\n<script src=\"../../site_libs/Proj4Leaflet-1.0.1/proj4leaflet.js\"></script>\n<link href=\"../../site_libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/leaflet-binding-2.2.1/leaflet.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}